print("No max declaration. Set to default 1")
upper = 1
}
# compatibility check
if(lower >= upper) {
stop("min must be smaller than max.")
}
# density function
density_function = function(x) {
each_density = stats::dunif(x, min = lower, max = upper)
return(apply(each_density, 1, prod))
}
} else{
stop("Not implemented yet. Please use gaussian or uniform as a prior.")
}
return(density_function)
}
# gradient descent in solution manifold.
sol_mfd_grad_descent = function(N, d, quadratic_f, grad_f, sampling_function, gamma = 0.1, tol1 = 1e-07, tol2 = 1e-15, num_iter = 1000) {
final_mat = matrix(0, N, d)
i = 1
iter = 0
while(i <= N) {
# sampling required points
curr_point = sampling_function(1)
curr_point = grad_descent(curr_point, grad_f, d, gamma, tol2, num_iter)
# whether obtained points are in sol_mfd
eval_point = as.numeric(quadratic_f(curr_point))
# no convergence to manifold.
if(eval_point > tol1) {
next
}
# conv to manifold
final_mat[i, ] = curr_point
# updated number of samples this time
i = i + 1
# reached maximum number of iteration
if (num_iter < iter) {
stop("Reached maximum iteration before getting N points. Try larger num_iter or different hyperparams.")
}
iter = iter + 1
}
return(final_mat)
}
# gradient descending in general case.
grad_descent = function(curr_point, grad_f, d, gamma, tol, num_iter) {
# error: to evaluate the convergence of grad_descent
error = sum((curr_point)^2)
new_point = curr_point
iter = 0
# perform grad_descent
while(error > tol) {
# update
new_point = curr_point - gamma * grad_f(curr_point)
# checking convergence
error = sum((new_point - curr_point)^2)
# update
curr_point = new_point
# check maximum iter
if(iter > num_iter) {
stop("Reached maximum iteration before grad_descent converge. Try larger num_iter or different hyperparams.")
}
iter = iter + 1
}
return(curr_point)
}
#' @examples
#' set.seed(10)
#' N = 10
#' phi = function(x) {return(pnorm(2, x[[1]], x[[2]]) - pnorm(-5, x[[1]], x[[2]]) - 0.5)}
#' d = 2
#' s = 1
#' res_points = sol_mfd_points(N, phi, d, s, prior = "uniform")
#' head(res_points)
#' phi(res_points[1, ]) # are they on solution manifold?
#' plot(res_points, xlab = "mean", ylab = "sigma", type = 'o') # how they are distributed
sol_mfd_points = function(N, phi, d, s, prior = "gaussian", gamma = 0.005, Lambda = NULL, tol1 = 1e-07, tol2 = 1e-15, num_iter = 100000, ...) {
# construct positive definite function
# compatibility check
if(is.null(Lambda)) {
Lambda = diag(s)
} else {
if(nrow(Lambda) != s || ncol(Lambda) != s) {
stop("Incorrect dimension for Lambda. Lambda must be s x s dim matrix")
}
if(!matrixcalc::is.positive.definite(Lambda)) {
stop("Lambda must be positive definite matrix")
}
}
# result saving matrix
final_points = matrix(0, nrow = N, ncol = d)
iter = 0
# quadratic form and grad of this to run and evaluate algorithm
quadratic_f = pd_function(phi, Lambda)
grad_f = grad_of_quadratic_f(phi, Lambda)
# designate sampling function
sampling_function = sampling_from_dist(d, prior, ...)
final_points = sol_mfd_grad_descent(N, d, quadratic_f, grad_f, sampling_function, gamma, tol1, tol2, num_iter)
return(final_points)
}
#' nll = function(theta) {return(-sum(dnorm(X, theta[[1]], theta[[2]], log = TRUE)))}
#' # constraint
#' C = function(x) {return(pnorm(2, x[[1]], x[[2]]) - pnorm(-5, x[[1]], x[[2]]) - 0.5)}
#' theta = runif(2, 1, 3)
#' theta_updated = constraint_likelihood(nll, C, theta, 1)
#' # plot the convergences
#' plot(x = seq(1, nrow(theta_updated)), apply(theta_updated, 1, C), xlab = "step", ylab = "constraint", type = 'o')
#' plot(x = seq(1, nrow(theta_updated)), apply(theta_updated, 1, nll), xlab = "step", ylab = "nll", type = 'o')
#' plot(theta_updated, xlab = "mean", ylab = "sigma", type = 'o')
#' lines(theta_updated[seq(3, nrow(theta_updated), by = 2), ],  col = 'red')
constraint_likelihood = function(nll, C, theta, s, alpha = 0.005, gamma = 0.005, Lambda = NULL, tol1 = 1e-07, tol2 = 1e-15, num_iter = 100000, num_iter2 = 20) {
d = length(theta)
# compatibility check
if(is.null(Lambda)) {
Lambda = diag(s)
} else {
if(nrow(Lambda) != s || ncol(Lambda) != s) {
stop("Incorrect dimension for Lambda. Lambda must be s x s dim matrix")
}
if(!matrixcalc::is.positive.definite(Lambda)) {
stop("Lambda must be positive definite matrix")
}
}
grad_nll = grad_of_f(nll)
quadratic_f = pd_function(C, Lambda)
grad_f = grad_of_quadratic_f(C, Lambda)
grad_c = grad_of_f(C)
theta_traj = matrix(NA, 2 * num_iter2 + 1, d)
theta_traj[1, ] = theta
# likelihood update
for(i in 1:num_iter2) {
# gradient descent to negative log likelihood (i.e. gradient ascending to log-likelihood.)
# only one step
theta = theta - alpha * grad_nll(theta)
theta_traj[2 * i, ] = theta
# descent to manifold, until it reaches manifold.
theta = grad_descent(theta, grad_f, d, gamma, tol2, num_iter)
if(quadratic_f(theta) > tol1) {
stop("this theta does not converge to manifold. pick different theta.")
}
theta_traj[2 * i + 1, ] = theta
# stopping criterion: grad_nll(theta) \in span(row(grad_C))
# grad_nll \in row_grad_c
grad_c_mat = grad_c(theta)
# check grad_nll can be approximated by linear projection of rows of grad_c
linear_projection = crossprod(grad_c_mat, solve(tcrossprod(grad_c_mat, grad_c_mat)) %*% grad_c_mat)
target = grad_nll(theta)
row_space_error = sum((target %*% linear_projection - target)^2)
# error < tol1
if (row_space_error < tol2) {
break
}
}
# return with removing NA's
return(theta_traj[!rowSums(!is.finite(theta_traj)),])
}
#'
#' @examples
#' set.seed(10)
#' k = get("dnorm", mode = 'function')
#' prob_density = function(x, theta) {return(dnorm(x, mean = theta[[1]], sd = theta[[2]]))}
#' n = 100
#' X = rnorm(n, 1.5, 3)
#' points = sol_mfd_points(N, phi, d, s, prior = "uniform")
#' res_with_density = post_density_solmfd(X, prob_density, points, k)
#' head(res_with_density)
post_density_solmfd = function(X, prob_density, points, k, h = 1, prior = "gaussian", ...) {
if(!is.matrix(points)) {
stop("data must be matrix.")
}
# input dim
d = ncol(points)
# kernel
dist_between_row = between_row_dist(points, points)
normalized = dist_between_row / h
kerneled = k(normalized)
# mean by N
rho_i = rowMeans(kerneled)
# calculate the \hat(pi_i) = \pi(Z_i) \prod(p(X_j | Z+i))
# calculate pi_i
# prior setting
# designate sampling function
density_function = density_from_dist(d, prior, ...)
pi_z = density_function(points)
# conditioning X ftn for vectoization
z_conditioning_x = function(z) { return(prob_density(X, z)) }
pi_i = exp(log(pi_z) + colSums(log(apply(points, 1, z_conditioning_x))))
omega_i = pi_i / rho_i
return(omega_i)
}
set.seed(10)
N = 10
phi = function(x) {return(pnorm(2, x[[1]], x[[2]]) - pnorm(-5, x[[1]], x[[2]]) - 0.5)}
d = 2
s = 1
res_points = sol_mfd_points(N, phi, d, s, prior = "uniform")
head(res_points)
phi(res_points[1, ]) # are they on solution manifold?
plot(res_points, xlab = "mean", ylab = "sigma") # how they are distributed
# init value
set.seed(10)
# num of samples
n = 100
# data distribution
X = rnorm(n, mean = 1.5, sd = 3)
# negative log likelihood
nll = function(theta) {return(-sum(dnorm(X, theta[[1]], theta[[2]], log = TRUE)))}
# constraint
C = function(x) {return(pnorm(2, x[[1]], x[[2]]) - pnorm(-5, x[[1]], x[[2]]) - 0.5)}
theta = runif(2, 1, 3)
theta_updated = SolMfd::constraint_likelihood(nll, C, theta, 1)
# plot the convergences
plot(x = seq(1, nrow(theta_updated)), apply(theta_updated, 1, C), xlab = "step", ylab = "constraint", type = 'o')
# plot the convergences
plot(x = seq(1, nrow(theta_updated)), apply(theta_updated, 1, C), xlab = "step", ylab = "constraint", type = 'o')
plot(x = seq(1, nrow(theta_updated)), apply(theta_updated, 1, nll), xlab = "step", ylab = "nll", type = 'o')
plot(theta_updated, xlab = "mean", ylab = "sigma", type = 'o')
plot(theta_updated, xlab = "mean", ylab = "sigma", type = 'o')
lines(theta_updated[seq(3, nrow(theta_updated), by = 2), ],  col = 'red')
k = get("dnorm", mode = 'function')
prob_density = function(x, theta) {return(dnorm(x, mean = theta[[1]], sd = theta[[2]]))}
n = 100
X = rnorm(n, 1.5, 3)
res_with_density = post_density_solmfd(X, prob_density, res_points, k, prior = "uniform", min = 0, max = 10)
head(res_with_density)
res_with_density = post_density_solmfd(X, prob_density, res_points, k)
head(res_with_density)
plot(res_points)
detach("pakage: SolMfd")
detach("package: SolMfd")
detach("packages: SolMfd")
library(SolMfd)
N = 30
phi = function(x) {return(pnorm(2, x[[1]], x[[2]]) - pnorm(-5, x[[1]], x[[2]]) - 0.5)}
d = 2
s = 1
res_points = sol_mfd_points(N, phi, d, s, prior = "uniform")
head(res_points)
phi(res_points[1, ]) # are they on solution manifold?
plot(res_points, xlab = "mean", ylab = "sigma") # how they are distributed
res_points = sol_mfd_points(N, phi, d, s, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(2, 1, 1, 3)))
res_points = sol_mfd_points(N, phi, d, s, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(2, 1, 1, 3), 2, 2))
res_points = sol_mfd_points(N, phi, d, s, gamma = 0.1, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(2, 1, 1, 3), 2, 2))
head(res_points)
phi(res_points[1, ]) # are they on solution manifold?
plot(res_points, xlab = "mean", ylab = "sigma") # how they are distributed
N = 50
phi = function(x) {return(pnorm(2, x[[1]], x[[2]]) - pnorm(-5, x[[1]], x[[2]]) - 0.5)}
d = 2
s = 1
res_points = sol_mfd_points(N, phi, d, s, gamma = 0.1, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(2, 1, 1, 3), 2, 2))
head(res_points)
phi(res_points[1, ]) # are they on solution manifold?
plot(res_points, xlab = "mean", ylab = "sigma") # how they are distributed
library(SolMfd)
detach("SolMfd")
detach("package: SolMfd")
detach("package:SolMfd")
devtools::install_github("wldyddl5510/SolMfd")
library(SolMfd)
set.seed(10) # for consistency
N = 50
phi = function(x) {return(pnorm(2, x[[1]], x[[2]]) - pnorm(-5, x[[1]], x[[2]]) - 0.5)}
d = 2
s = 1
res_point1 = sol_mfd_points(N, phi, d, s, prior = "uniform")
apply(res_point1, 1, phi) # are they on solution manifold?
plot(res_points1, xlab = "mean", ylab = "sigma") # how they are distributed
res_point1 = sol_mfd_points(N, phi, d, s, prior = "uniform")
res_point1 = sol_mfd_points(N, phi, d, s, prior = "uniform", min = 0, max = 3)
res_point1 = sol_mfd_points(N, phi, d, s, prior = "uniform", gamma = 0.01, min = 0, max = 3)
head(apply(res_point1, 1, phi)) # are they on solution manifold?
plot(res_point1, xlab = "mean", ylab = "sigma") # how they are distributed
res_points = sol_mfd_points(N, phi, d, s, gamma = 0.1, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(2, 1, 1, 3), 2, 2))
res_points = sol_mfd_points(N, phi, d, s, gamma = 0.1, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(2, 1, 1, 3), 2, 2), num_iter = 1e+10)
res_points = sol_mfd_points(N, phi, d, s, gamma = 0.1, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(2, 1, 1, 3), 2, 2))
res_points = sol_mfd_points(N, phi, d, s, gamma = 0.1, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(2, 1, 1, 0.5), 2, 2))
res_points = sol_mfd_points(N, phi, d, s, gamma = 0.1, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(1, 0.25, 0.25, 1), 2, 2))
head(res_points)
apply(res_point1, 1, phi) # are they on solution manifold?
plot(res_points, xlab = "mean", ylab = "sigma") # how they are distributed
plot(res_point1, xlab = "mean", ylab = "sigma") # how they are distributed
points(res_points)
plot(res_point1, xlab = "mean", ylab = "sigma") # how they are distributed
points(res_points, col = 'red')
res_point2 = sol_mfd_points(N, phi, d, s, gamma = 0.1, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(1, 0.25, 0.25, 1), 2, 2))
head(apply(res_point2, 1, phi)) # are they on solution manifold?
plot(res_point2, xlab = "mean", ylab = "sigma") # how they are distributed
plot(res_point2, xlab = "mean", ylab = "sigma") # how they are distributed
res_point2 = sol_mfd_points(N, phi, d, s, gamma = 0.1, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(1, 0.25, 0.25, 1), 2, 2))
head(apply(res_point2, 1, phi)) # are they on solution manifold?
plot(res_point2, xlab = "mean", ylab = "sigma") # how they are distributed
library(SolMfd)
set.seed(10) # for consistency
N = 50
phi = function(x) {return(pnorm(2, x[[1]], x[[2]]) - pnorm(-5, x[[1]], x[[2]]) - 0.5)}
d = 2
s = 1
res_point1 = sol_mfd_points(N, phi, d, s, prior = "uniform", gamma = 0.01, min = 0, max = 3)
head(apply(res_point1, 1, phi)) # are they on solution manifold?
plot(res_point1, xlab = "mean", ylab = "sigma") # how they are distributed
res_point2 = sol_mfd_points(N, phi, d, s, gamma = 0.1, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(1, 0.25, 0.25, 1), 2, 2))
head(apply(res_point2, 1, phi)) # are they on solution manifold?
plot(res_point2, xlab = "mean", ylab = "sigma") # how they are distributed
n = 100
X = rnorm(n, mean = 1.5, sd = 3) # data for likelihood
res_point2 = sol_mfd_points(N, phi, d, s, gamma = 0.1, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(1, 0.25, 0.25, 1), 2, 2))
head(apply(res_point2, 1, phi)) # are they on solution manifold?
plot(res_point2, xlab = "mean", ylab = "sigma") # how they are distributed
n = 100
X = rnorm(n, mean = 1.5, sd = 3) # data for likelihood
nll = function(theta) {return(-sum(dnorm(X, theta[[1]], theta[[2]], log = TRUE)))}
n = 100
X = rnorm(n, mean = 1.5, sd = 3) # data for likelihood
nll = function(theta) {return(-sum(dnorm(X, theta[[1]], theta[[2]], log = TRUE)))}
theta = runif(2, 1, 3)
theta_updated = constraint_likelihood(nll, phi, theta, 1, num_iter2 = 25)
const_val = apply(theta_updated, 1, phi)
plot(x = seq(1, nrow(theta_updated)), const_val, xlab = "step", ylab = "constraint", type = 'o')
const_val = apply(theta_updated, 1, phi)
plot(x = seq(1, nrow(theta_updated)), const_val, xlab = "step", ylab = "constraint", type = 'o')
nll_val = apply(theta_updated, 1, nll)
plot(x = seq(1, nrow(theta_updated)), nll_val, xlab = "step", ylab = "nll", type = 'o')
theta_updated[nrow(theta_updated), ]
theta_updated[1, ]
theta_updated[nrow(theta_updated), ]
plot(theta_updated)
nll_val = apply(theta_updated, 1, nll)
plot(x = seq(1, nrow(theta_updated)), nll_val, xlab = "step", ylab = "nll", type = 'o')
nll_val = apply(theta_updated, 1, nll)
plot(x = seq(1, nrow(theta_updated)), nll_val, xlab = "step", ylab = "nll", type = 'o')
plot(theta_updated, xlab = "mean", ylab = "sigma", type = 'o')
lines(theta_updated[seq(3, nrow(theta_updated), by = 2), ],  col = 'red')
plot(theta_updated, xlab = "mean", ylab = "sigma", type = 'o')
lines(theta_updated[seq(3, nrow(theta_updated), by = 2), ],  col = 'red')
points(c(1.5, 3), col = "blue")
plot(theta_updated, xlab = "mean", ylab = "sigma", type = 'o')
lines(theta_updated[seq(3, nrow(theta_updated), by = 2), ],  col = 'red')
point(c(1.5, 3), col = "blue")
plot(theta_updated, xlab = "mean", ylab = "sigma", type = 'o')
lines(theta_updated[seq(3, nrow(theta_updated), by = 2), ],  col = 'red')
points(c(1.5, 3), col = "blue")
plot(theta_updated, xlab = "mean", ylab = "sigma", type = 'o')
lines(theta_updated[seq(3, nrow(theta_updated), by = 2), ],  col = 'red')
points(1.5, 3, col = "blue")
theta_updated2 = constraint_likelihood(nll, phi, theta, 1, alpha = 0.05, num_iter2 = 25)
theta_updated2 = constraint_likelihood(nll, phi, theta, 1, alpha = 0.05, num_iter2 = 25)
plot(theta_updated2, xlab = "mean", ylab = "sigma", type = 'o')
lines(theta_updated2[seq(3, nrow(theta_updated), by = 2), ],  col = 'red')
points(1.5, 3, col = "blue")
prob_density = function(x, theta) {return(dnorm(x, mean = theta[[1]], sd = theta[[2]]))}
n = 100
X = rnorm(n, 1.5, 3)
k = get("dnorm", mode = 'function')
res_with_density = post_density_solmfd(X, prob_density, res_point1, k)
res_with_density = post_density_solmfd(X, prob_density, res_point1, k)
res_with_density
which.max(res_with_density)
res_point1[which.max(res_with_density),]
res_point1
head(res_with_density)
apply(res_point1, 1, nll)
which.max(apply(res_point1, 1, nll))
which.max(apply(res_point1, 1, min))
apply(res_point1, 1, min)[26]
apply(res_point1, 1, min)
res_point1
tmp = apply(ress_point2, 1, nll)
tmp = apply(res_point2, 1, nll)
res_point2
set.seed(10) # for consistency
N = 50
phi = function(x) {return(pnorm(2, x[[1]], x[[2]]) - pnorm(-5, x[[1]], x[[2]]) - 0.5)}
d = 2
s = 1
res_point1 = sol_mfd_points(N, phi, d, s, prior = "uniform", gamma = 0.01, min = 0, max = 3)
res_point1 = sol_mfd_points(N, phi, d, s, prior = "uniform", gamma = 0.01, min = 0, max = 3)
res_point_tmp = res_point1
head(apply(res_point_tmp, 1, phi)) # are they on solution manifold?
plot(res_point1, xlab = "mean", ylab = "sigma") # how they are distributed
res_point2 = sol_mfd_points(N, phi, d, s, gamma = 0.1, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(1, 0.25, 0.25, 1), 2, 2))
res_point_tmp = res_point2
head(apply(res_point2, 1, phi)) # are they on solution manifold?
plot(res_point2, xlab = "mean", ylab = "sigma") # how they are distributed
res_point2 = sol_mfd_points(N, phi, d, s, gamma = 0.1, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(1, 0.25, 0.25, 1), 2, 2))
res_point2 = sol_mfd_points(N, phi, d, s, gamma = 0.1, prior = "gaussian", mean = c(0, 3), sigma = matrix(c(1, 0.25, 0.25, 1), 2, 2))
res_point_tmp = res_point2
head(apply(res_point_tmp, 1, phi)) # are they on solution manifold?
plot(res_point2, xlab = "mean", ylab = "sigma") # how they are distributed
n = 100
X = rnorm(n, mean = 1.5, sd = 3) # data for likelihood
nll = function(theta) {return(-sum(dnorm(X, theta[[1]], theta[[2]], log = TRUE)))}
theta = runif(2, 1, 3)
theta_updated = constraint_likelihood(nll, phi, theta, 1, num_iter2 = 25)
theta = runif(2, 1, 3)
theta_updated = constraint_likelihood(nll, phi, theta, 1, num_iter2 = 25)
theta_updated[1, ]
theta_updated[nrow(theta_updated), ]
theta_tmp = theta_updated
const_val = apply(theta_tmp, 1, phi)
plot(x = seq(1, nrow(theta_updated)), const_val, xlab = "step", ylab = "constraint", type = 'o')
theta_tmp = theta_updated
nll_val = apply(theta_tmp, 1, nll)
plot(x = seq(1, nrow(theta_updated)), nll_val, xlab = "step", ylab = "nll", type = 'o')
plot(theta_updated, xlab = "mean", ylab = "sigma", type = 'o')
lines(theta_updated[seq(3, nrow(theta_updated), by = 2), ],  col = 'red')
points(1.5, 3, col = "blue")
theta_updated2 = constraint_likelihood(nll, phi, theta, 1, alpha = 0.05, num_iter2 = 25)
theta = runif(2, 0, 1)
theta_updated = constraint_likelihood(nll, phi, theta, 1, num_iter2 = 25)
theta = runif(2, 0, 1)
theta_updated = constraint_likelihood(nll, phi, theta, 1, num_iter2 = 25)
theta = runif(2, 0.5, 1.5)
theta_updated = constraint_likelihood(nll, phi, theta, 1, num_iter2 = 25)
theta = runif(2, 0.5, 1.5)
theta_updated = constraint_likelihood(nll, phi, theta, 1, num_iter2 = 25)
theta_updated[1, ]
theta_updated[nrow(theta_updated), ]
theta_tmp = theta_updated
const_val = apply(theta_tmp, 1, phi)
plot(x = seq(1, nrow(theta_updated)), const_val, xlab = "step", ylab = "constraint", type = 'o')
theta_tmp = theta_updated
nll_val = apply(theta_tmp, 1, nll)
plot(x = seq(1, nrow(theta_updated)), nll_val, xlab = "step", ylab = "nll", type = 'o')
plot(theta_updated, xlab = "mean", ylab = "sigma", type = 'o')
lines(theta_updated[seq(3, nrow(theta_updated), by = 2), ],  col = 'red')
points(1.5, 3, col = "blue")
theta_updated2 = constraint_likelihood(nll, phi, theta, 1, alpha = 0.05, num_iter2 = 25)
theta = runif(2, 0, 3)
theta_updated = constraint_likelihood(nll, phi, theta, 1, num_iter2 = 25)
theta = runif(2, 0, 3)
theta_updated = constraint_likelihood(nll, phi, theta, 1, num_iter1 = 1e+07, num_iter2 = 25)
theta = runif(2, 0, 3)
theta_updated = constraint_likelihood(nll, phi, theta, 1, num_iter1 = 10000000, num_iter2 = 25)
theta = runif(2, 0, 3)
theta_updated = constraint_likelihood(nll, phi, theta, 1, num_iter = 1e+07, num_iter2 = 25)
theta_updated[1, ]
theta_updated[nrow(theta_updated), ]
theta_tmp = theta_updated
const_val = apply(theta_tmp, 1, phi)
plot(x = seq(1, nrow(theta_updated)), const_val, xlab = "step", ylab = "constraint", type = 'o')
theta_tmp = theta_updated
nll_val = apply(theta_tmp, 1, nll)
plot(x = seq(1, nrow(theta_updated)), nll_val, xlab = "step", ylab = "nll", type = 'o')
plot(theta_updated, xlab = "mean", ylab = "sigma", type = 'o')
lines(theta_updated[seq(3, nrow(theta_updated), by = 2), ],  col = 'red')
points(1.5, 3, col = "blue")
theta_updated2 = constraint_likelihood(nll, phi, theta, 1, alpha = 0.05, num_iter2 = 25)
theta_updated2 = constraint_likelihood(nll, phi, theta, 1, alpha = 0.05, num_iter = 1e+07, num_iter2 = 25)
plot(theta_updated2, xlab = "mean", ylab = "sigma", type = 'o')
lines(theta_updated2[seq(3, nrow(theta_updated2), by = 2), ],  col = 'red')
points(1.5, 3, col = "blue")
res_point_tmp = res_point1
nll_for_res1 = apply(res_point_tmp, 1, nll)
which.min(nll_for_res1)
which.max(res_with_density)
res_point_tmp = res_point1
nll_for_res1 = apply(res_point_tmp, 1, nll)
res_point1[which.min(nll_for_res1), ]
res_point1[which.max(res_with_density), ]
res_with_density = post_density_solmfd(X, prob_density, res_point1, k)
head(res_with_density)
res_point_tmp = res_point1
nll_for_res1 = apply(res_point_tmp, 1, nll)
res_point1[which.min(nll_for_res1), ]
res_point1[which.max(res_with_density), ]
res_point_tmp = res_point1
nll_for_res1 = apply(res_point_tmp, 1, nll)
res_point1[which.min(nll_for_res1), ]
res_point1[which.max(res_with_density), ]
res_with_density[which.min(nll_for_res1)]
res_with_density2 = post_density_solmfd(X, prob_density, res_point2, k)
res_point_tmp = res_point2
nll_for_res2 = apply(res_point_tmp, 1, nll)
res_point1[which.min(nll_for_res2), ]
res_point1[which.max(res_with_density2), ]
res_with_density2 = post_density_solmfd(X, prob_density, res_point2, k)
res_point_tmp = res_point2
nll_for_res2 = apply(res_point_tmp, 1, nll)
res_point2[which.min(nll_for_res2), ]
res_point2[which.max(res_with_density2), ]
library(SolMfd)
install.packages(c("knitr", "formatR"))
install.packages(c("knitr", "formatR"))
install.packages(c("knitr", "formatR"))
devtools::install_github("wldyddl5510/SolMfd", build_vignettes = T)
res_with_density = post_density_solmfd(X, prob_density, points, k)
library(SolMfd)
library(SolMfd)
theta_updated = constraint_likelihood(nll, C, c(1,2), 1, num_iter = 1e+07, num_iter2 = 25)
library(SolMfd)
# init value
set.seed(10)
# num of samples
n = 100
# data distribution
X = rnorm(n, mean = 1.5, sd = 3)
# negative log likelihood
nll = function(theta) {return(-sum(dnorm(X, theta[[1]], theta[[2]], log = TRUE)))}
# constraint
C = function(x) {return(pnorm(2, x[[1]], x[[2]]) - pnorm(-5, x[[1]], x[[2]]) - 0.5)}
theta_updated = constraint_likelihood(nll, C, c(1, 2), 1)
theta_updated
# plot the convergences
const_val = apply(theta_updated, 1, C)
plot(x = seq(1, nrow(theta_updated)), const_val, xlab = "step", ylab = "constraint", type = 'o')
nll_val = apply(theta_updated, 1, nll)
plot(x = seq(1, nrow(theta_updated)), nll_val, xlab = "step", ylab = "nll", type = 'o')
plot(theta_updated, xlab = "mean", ylab = "sigma", type = 'o')
lines(theta_updated[seq(3, nrow(theta_updated), by = 2), ],  col = 'red')
library(SolMfd)
library(SolMfd)
